"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.R2Vector = void 0;
const S2Point_1 = require("./S2Point");
/**
 * R2Vector represents a vector in the two-dimensional space. It defines the
 * basic geometrical operations for 2D vectors, e.g. cross product, addition,
 * norm, comparison etc.
 *
 */
class R2Vector {
    constructor(_x, _y) {
        this._x = _x;
        this._y = _y;
    }
    get x() {
        return this._x;
    }
    get y() {
        return this._y;
    }
    get(index) {
        if (index < 0 || index > 1) {
            throw new Error(`Index out fo bounds error ${index}`);
        }
        return index == 0 ? this._x : this._y;
    }
    static fromPointFace(p, face) {
        return p.toR2Vector(face);
    }
    static add(p1, p2) {
        return new R2Vector(p1._x + (p2._x), p1._y + (p2._y));
    }
    static mul(p, m) {
        return new R2Vector(m * (p._x), m * (p._y));
    }
    norm2() {
        return this.x * this.x + this.y * this.y;
    }
    static dotProd(p1, p2) {
        return p1.x * (p2.x) + (p1.y * (p2.y));
    }
    dotProd(that) {
        return R2Vector.dotProd(this, that);
    }
    crossProd(that) {
        return this.x * (that.y) - (this.y * (that.x));
    }
    lessThan(vb) {
        if (this.x < (vb.x)) {
            return true;
        }
        if (vb.x < (this.x)) {
            return false;
        }
        if (this.y < (vb.y)) {
            return true;
        }
        return false;
    }
    //
    // @Override
    // public boolean equals(Object that) {
    //   if (!(that instanceof R2Vector)) {
    //     return false;
    //   }
    //   R2Vector thatPoint = (R2Vector) that;
    //   return this.x == thatPoint.x && this.y == thatPoint.y;
    // }
    // /**
    //  * Calcualates hashcode based on stored coordinates. Since we want +0.0 and
    //  * -0.0 to be treated the same, we ignore the sign of the coordinates.
    //  */
    // @Override
    // public int hashCode() {
    //   long value = 17;
    //   value += 37 * value + Double.doubleToLongBits(Math.abs(x));
    //   value += 37 * value + Double.doubleToLongBits(Math.abs(y));
    //   return (int) (value ^ (value >>> 32));
    // }
    //
    static fromSTVector(stVector) {
        return new R2Vector(R2Vector.singleStTOUV(stVector.x), R2Vector.singleStTOUV(stVector.y));
    }
    // from S2Projections.stToUV (QUADRATIC)
    static singleStTOUV(s) {
        if (s >= 0.5) {
            return (1 / 3) * (4 * s * s - 1);
        }
        else {
            return (1 / 3) * (1 - 4 * (1 - s) * (1 - s));
        }
    }
    static singleUVToST(u) {
        if (u >= 0) {
            return 0.5 * Math.sqrt(1 + 3 * u);
        }
        else {
            return 1 - 0.5 * Math.sqrt(1 - 3 * u);
        }
    }
    /**
     * To be used only if this vector is representing uv.
     * @param face
     * @returns {S2Point}
     */
    toPoint(face) {
        switch (face) {
            case 0:
                return new S2Point_1.S2Point(1, this.x, this.y);
            case 1:
                return new S2Point_1.S2Point(this.x * -1, 1, this.y);
            case 2:
                return new S2Point_1.S2Point(this.x * -1, this.y * -1, 1);
            case 3:
                return new S2Point_1.S2Point(-1, this.y * -1, this.x * -1);
            case 4:
                return new S2Point_1.S2Point(this.y, -1, this.x * -1);
            default:
                return new S2Point_1.S2Point(this.y, this.x, -1);
        }
    }
    toSt(which) {
        return which == 0 ? R2Vector.singleUVToST(this.x) : R2Vector.singleUVToST(this.y);
    }
    toString() {
        return "(" + this.x.toString() + ", " + this.y.toString() + ")";
    }
}
exports.R2Vector = R2Vector;
//# sourceMappingURL=R2Vector.js.map