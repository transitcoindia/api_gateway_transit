import { R2Vector } from "./R2Vector";
/**
 * An S2Point represents a point on the unit sphere as a 3D vector. Usually
 * points are normalized to be unit length, but some methods do not require
 * this.
 *
 */
export declare class S2Point {
    /** Origin of the coordinate system, [0,0,0]. */
    static ORIGIN: S2Point;
    /** Direction of the x-axis. */
    static X_POS: S2Point;
    /** Opposite direction of the x-axis. */
    static X_NEG: S2Point;
    /** Direction of the y-axis. */
    static Y_POS: S2Point;
    /** Opposite direction of the y-axis. */
    static Y_NEG: S2Point;
    /** Direction of the z-axis. */
    static Z_POS: S2Point;
    /** Opposite direction of the z-axis. */
    static Z_NEG: S2Point;
    x: number;
    y: number;
    z: number;
    constructor(x: number, y: number, z: number);
    static minus(p1: S2Point, p2: S2Point): S2Point;
    static neg(p: S2Point): S2Point;
    norm2(): number;
    norm(): number;
    static crossProd(p1: S2Point, p2: S2Point): S2Point;
    static add(p1: S2Point, p2: S2Point): S2Point;
    static sub(p1: S2Point, p2: S2Point): S2Point;
    dotProd(that: S2Point): number;
    static mul(p: any, m: number): S2Point;
    static div(p: S2Point, m: number): S2Point;
    /**
     * Returns the distance in 3D coordinates from this to that.
     *
     * <p>Equivalent to {@code a.sub(b).norm()}, but significantly faster.
     *
     * <p>If ordering points by angle, this is faster than {@link #norm}, and much faster than {@link
    * #angle}, but consider using {@link S1ChordAngle}.
    */
    getDistance(that: S2Point): number;
    /**
     * Returns the square of the distance in 3D coordinates from this to that.
     *
     * <p>Equivalent to {@code getDistance(that)<sup>2</sup>}, but significantly faster.
     *
     * <p>If ordering points by angle, this is much faster than {@link #angle}, but consider using
     * {@link S1ChordAngle}.
     */
    getDistance2(that: S2Point): number;
    /** return a vector orthogonal to this one */
    ortho(): S2Point;
    /** Return the index of the largest component fabs */
    largestAbsComponent(): number;
    static largestAbsComponent(x: number, y: number, z: number): number;
    get(axis: number): number;
    static fabs(p: S2Point): S2Point;
    /** Returns a copy of 'p' rescaled to be unit-length. */
    static normalize(p: S2Point): S2Point;
    axis(axis: number): number;
    /** Return the angle between two vectors in radians */
    angle(va: any): number;
    /**
     * Compare two vectors, return true if all their components are within a
     * difference of margin.
     */
    aequal(that: S2Point, margin: number): boolean;
    equals(that: S2Point): boolean;
    lessThan(vb: S2Point): boolean;
    compareTo(other: S2Point): number;
    toFace(): number;
    toR2Vector(face?: number): R2Vector;
    toString(): string;
}
