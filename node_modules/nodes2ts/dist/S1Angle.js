"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.S1Angle = void 0;
class S1Angle {
    constructor(radians) {
        this.radians = radians;
    }
    degrees() {
        return this.radians * 180 / Math.PI;
    }
    //
    // public long e5() {
    //   return Math.round(degrees() * 1e5);
    // }
    //
    // public long e6() {
    //   return Math.round(degrees() * 1e6);
    // }
    //
    // public long e7() {
    //   return Math.round(degrees() * 1e7);
    // }
    /**
     * Return the angle between two points, which is also equal to the distance
     * between these points on the unit sphere. The points do not need to be
     * normalized.
     */
    static fromPoints(x, y) {
        return new S1Angle(x.angle(y));
    }
    lessThan(that) {
        return this.radians < (that.radians);
    }
    greaterThan(that) {
        return this.radians > (that.radians);
    }
    lessOrEquals(that) {
        return this.radians <= (that.radians);
    }
    greaterOrEquals(that) {
        return this.radians >= (that.radians);
    }
    static max(left, right) {
        return right.greaterThan(left) ? right : left;
    }
    static min(left, right) {
        return right.greaterThan(left) ? left : right;
    }
    static radians(radians) {
        return new S1Angle(radians);
    }
    static degrees(degrees) {
        return new S1Angle(degrees * (Math.PI / 180));
    }
    /**
   * Retuns an {@link S1Angle} whose angle is <code>(this + a)</code>.
   */
    add(a) {
        return new S1Angle(this.radians + a.radians);
    }
    /**
     * Retuns an {@link S1Angle} whose angle is <code>(this - a)</code>.
     */
    sub(a) {
        return new S1Angle(this.radians - a.radians);
    }
    /**
     * Retuns an {@link S1Angle} whose angle is <code>(this * m)</code>.
     */
    mul(m) {
        return new S1Angle(this.radians * m);
    }
    /**
     * Retuns an {@link S1Angle} whose angle is <code>(this / d)</code>.
     */
    div(d) {
        return new S1Angle(this.radians / d);
    }
    /**
     * Returns the trigonometric cosine of the angle.
     */
    cos() {
        return Math.cos(this.radians);
    }
    /**
     * Returns the trigonometric sine of the angle.
     */
    sin() {
        return Math.sin(this.radians);
    }
    /**
     * Returns the trigonometric tangent of the angle.
     */
    tan() {
        return Math.tan(this.radians);
    }
    /** Returns the distance along the surface of a sphere of the given radius. */
    distance(radius) {
        return this.radians * radius;
    }
    //
    // public static S1Angle e5(long e5) {
    //   return degrees(e5 * 1e-5);
    // }
    //
    // public static S1Angle e6(long e6) {
    //   // Multiplying by 1e-6 isn't quite as accurate as dividing by 1e6,
    //   // but it's about 10 times faster and more than accurate enough.
    //   return degrees(e6 * 1e-6);
    // }
    //
    // public static S1Angle e7(long e7) {
    //   return degrees(e7 * 1e-7);
    // }
    /**
     * Writes the angle in degrees with a "d" suffix, e.g. "17.3745d". By default
     * 6 digits are printed; this can be changed using setprecision(). Up to 17
     * digits are required to distinguish one angle from another.
     */
    toString() {
        return this.degrees() + "d";
    }
    compareTo(that) {
        return this.radians < that.radians ? -1 : this.radians > that.radians ? 1 : 0;
    }
    equals(that) {
        return this.compareTo(that) === 0;
    }
}
exports.S1Angle = S1Angle;
S1Angle.INFINITY = new S1Angle(Number.POSITIVE_INFINITY);
S1Angle.ZERO = new S1Angle(0);
//# sourceMappingURL=S1Angle.js.map