/**
 * S1ChordAngle represents the angle subtended by a chord (i.e., the straight 3D Cartesian line
 * segment connecting two points on the unit sphere). Its representation makes it very efficient for
 * computing and comparing distances, but unlike S1Angle it is only capable of representing angles
 * between 0 and Pi radians. Generally, S1ChordAngle should only be used in loops where many angles
 * need to be calculated and compared. Otherwise it is simpler to use S1Angle.
 *
 * <p>S1ChordAngle also loses some accuracy as the angle approaches Pi radians. Specifically, the
 * representation of (Pi - x) radians can be expected to have an error of about (1e-15 / x), with a
 * maximum error of about 1e-7.
 */
import { S1Angle } from './S1Angle';
import { S2Point } from './S2Point';
export declare class S1ChordAngle {
    /** Max value that can be returned from {@link #getLength2()}. */
    static MAX_LENGTH2: number;
    /** The zero chord angle. */
    static ZERO: S1ChordAngle;
    /** The chord angle of 90 degrees (a "right angle"). */
    static RIGHT: S1ChordAngle;
    /** The chord angle of 180 degrees (a "straight angle"). This is the max finite chord angle. */
    static STRAIGHT: S1ChordAngle;
    /**
     * A chord angle larger than any finite chord angle. The only valid operations on {@code INFINITY}
     * are comparisons and {@link S1Angle} conversions.
     */
    static INFINITY: S1ChordAngle;
    /**
     * A chord angle smaller than {@link #ZERO}. The only valid operations on {@code NEGATIVE} are
     * comparisons and {@link S1Angle} conversions.
     */
    static NEGATIVE: S1ChordAngle;
    private length2;
    /**
     * S1ChordAngles are represented by the squared chord length, which can range from 0 to {@code
     * MAX_LENGTH2}. {@link #INFINITY} uses an infinite squared length.
     */
    constructor(length2: number);
    /**
     * Constructs the S1ChordAngle corresponding to the distance between the two given points. The
     * points must be unit length.
     */
    static fromS2Point(x: S2Point, y: S2Point): S1ChordAngle;
    /**
     * Returns a new chord angle approximated from {@code angle} (see {@link
     * #getS1AngleConstructorMaxError()} for the max magnitude of the error).
     *
     * <p>Angles outside the range [0, Pi] are handled as follows:
     *
     * <ul>
     *   <li>{@link S1Angle#INFINITY} is mapped to {@link #INFINITY}
     *   <li>negative angles are mapped to {@link #NEGATIVE}
     *   <li>finite angles larger than Pi are mapped to {@link #STRAIGHT}
     * </ul>
     *
     * <p>Note that this operation is relatively expensive and should be avoided. To use {@link
     * S1ChordAngle} effectively, you should structure your code so that input arguments are converted
     * to S1ChordAngles at the beginning of your algorithm, and results are converted back to {@link
     * S1Angle}s only at the end.
     */
    static fromS1Angle(angle: S1Angle): S1ChordAngle;
    /**
     * Construct an S1ChordAngle from the squared chord length. Note that the argument is
     * automatically clamped to a maximum of {@code MAX_LENGTH2} to handle possible roundoff errors.
     * The argument must be non-negative.
     */
    static fromLength2(length2: number): S1ChordAngle;
    /** Returns whether the chord distance is exactly 0. */
    isZero(): boolean;
    /** Returns whether the chord distance is negative. */
    isNegative(): boolean;
    /** Returns whether the chord distance is exactly (positive) infinity. */
    isInfinity(): boolean;
    /** Returns true if the angle is negative or infinity. */
    isSpecial(): boolean;
    /**
     * Returns true if getLength2() is within the normal range of 0 to 4 (inclusive) or the angle is
     * special.
     */
    isValid(): boolean;
    /**
     * Convert the chord angle to an {@link S1Angle}. {@link #INFINITY} is converted to {@link
     * S1Angle#INFINITY}, and {@link #NEGATIVE} is converted to a negative {@link S1Angle}. This
     * operation is relatively expensive.
     */
    toAngle(): S1Angle;
    /** The squared length of the chord. (Most clients will not need this.) */
    getLength2(): number;
    /**
     * Returns the smallest representable S1ChordAngle larger than this object. This can be used to
     * convert a "<" comparison to a "<=" comparison.
     *
     * <p>Note the following special cases:
     *
     * <ul>
     *   <li>NEGATIVE.successor() == ZERO
     *   <li>STRAIGHT.successor() == INFINITY
     *   <li>INFINITY.Successor() == INFINITY
     * </ul>
     */
    /**
     * As {@link #successor}, but returns the largest representable S1ChordAngle less than this
     * object.
     *
     * <p>Note the following special cases:
     *
     * <ul>
     *   <li>INFINITY.predecessor() == STRAIGHT
     *   <li>ZERO.predecessor() == NEGATIVE
     *   <li>NEGATIVE.predecessor() == NEGATIVE
     * </ul>
     */
    /**
     * Returns a new S1ChordAngle whose chord distance represents the sum of the angular distances
     * represented by the 'a' and 'b' chord angles.
     *
     * <p>Note that this method is much more efficient than converting the chord angles to S1Angles
     * and adding those. It requires only one square root plus a few additions and multiplications.
     */
    static add(a: S1ChordAngle, b: S1ChordAngle): S1ChordAngle;
    /**
     * Subtract one S1ChordAngle from another.
     *
     * <p>Note that this method is much more efficient than converting the chord angles to S1Angles
     * and adding those. It requires only one square root plus a few additions and multiplications.
     */
    static sub(a: S1ChordAngle, b: S1ChordAngle): S1ChordAngle;
    /** Returns the smaller of the given instances. */
    static min(a: S1ChordAngle, b: S1ChordAngle): S1ChordAngle;
    /** Returns the larger of the given instances. */
    static max(a: S1ChordAngle, b: S1ChordAngle): S1ChordAngle;
    /** Returns the square of Math.sin(toAngle().radians()), but computed more efficiently. */
    static sin2(a: S1ChordAngle): number;
    /** Returns Math.sin(toAngle().radians()), but computed more efficiently. */
    static sin(a: S1ChordAngle): number;
    /** Returns Math.cos(toAngle().radians()), but computed more efficiently. */
    static cos(a: S1ChordAngle): number;
    /** Returns Math.tan(toAngle().radians()), but computed more efficiently. */
    static tan(a: S1ChordAngle): number;
    /**
     * Returns a new S1ChordAngle that has been adjusted by the given error bound (which can be
     * positive or negative). {@code error} should be the value returned by one of the error bound
     * methods below. For example:
     *
     * <pre>
     *    {@code S1ChordAngle a = new S1ChordAngle(x, y);}
     *    {@code S1ChordAngle a1 = a.plusError(a.getS2PointConstructorMaxError());}
     * </pre>
     *
     * <p>If this {@link #isSpecial}, we return {@code this}.
     */
    plusError(error: number): S1ChordAngle;
    /** Returns the error in {@link #fromS1Angle}. */
    getS1AngleConstructorMaxError(): number;
    /**
     * There is a relative error of {@code 2.5 * DBL_EPSILON} when computing the squared distance,
     * plus a relative error of {@code 2 * DBL_EPSILON} and an absolute error of {@code 16 *
     * DBL_EPSILON^2} because the lengths of the input points may differ from 1 by up to {@code 2 *
     * DBL_EPSILON} each. (This is the maximum length error in {@link S2Point#normalize}).
     */
    getS2PointConstructorMaxError(): number;
    /** Returns the string of the closest {@link S1Angle} to this chord distance. */
    toString(): string;
    compareTo(that: S1ChordAngle): number;
    equals(that: S1ChordAngle): boolean;
}
