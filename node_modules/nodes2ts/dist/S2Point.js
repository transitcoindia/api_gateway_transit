"use strict";
/*
 * Copyright 2006 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.S2Point = void 0;
const R2Vector_1 = require("./R2Vector");
///re
/**
 * An S2Point represents a point on the unit sphere as a 3D vector. Usually
 * points are normalized to be unit length, but some methods do not require
 * this.
 *
 */
class S2Point {
    constructor(x, y, z) {
        this.x = (x);
        this.y = (y);
        this.z = (z);
        // this.y = typeof(y) === 'number'?new Decimal(y):y as Decimal;
        // this.z = typeof(z) === 'number'?new Decimal(z):z as Decimal;
    }
    static minus(p1, p2) {
        return S2Point.sub(p1, p2);
    }
    static neg(p) {
        return new S2Point(p.x * -1, p.y * -1, p.z * -1);
    }
    norm2() {
        return Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2);
    }
    norm() {
        return Math.sqrt(this.norm2());
    }
    static crossProd(p1, p2) {
        return new S2Point(p1.y * (p2.z) - (p1.z * (p2.y)), p1.z * (p2.x) - (p1.x * (p2.z)), 
        // p1.z * p2.x - p1.x * p2.z,
        p1.x * (p2.y) - (p1.y * (p2.x))
        // p1.x * p2.y - p1.y * p2.x
        );
    }
    static add(p1, p2) {
        return new S2Point(p1.x + p2.x, p1.y + p2.y, p1.z + p2.z);
    }
    static sub(p1, p2) {
        return new S2Point(p1.x - p2.x, p1.y - p2.y, p1.z - p2.z);
    }
    dotProd(that) {
        return this.x * (that.x) + (this.y * that.y) + (this.z * (that.z));
    }
    static mul(p, m) {
        return new S2Point(m * (p.x), m * (p.y), m * (p.z));
    }
    static div(p, m) {
        return new S2Point(p.x / (m), p.y / (m), p.z / (m));
    }
    /**
     * Returns the distance in 3D coordinates from this to that.
     *
     * <p>Equivalent to {@code a.sub(b).norm()}, but significantly faster.
     *
     * <p>If ordering points by angle, this is faster than {@link #norm}, and much faster than {@link
    * #angle}, but consider using {@link S1ChordAngle}.
    */
    getDistance(that) {
        return Math.sqrt(this.getDistance2(that));
    }
    /**
     * Returns the square of the distance in 3D coordinates from this to that.
     *
     * <p>Equivalent to {@code getDistance(that)<sup>2</sup>}, but significantly faster.
     *
     * <p>If ordering points by angle, this is much faster than {@link #angle}, but consider using
     * {@link S1ChordAngle}.
     */
    getDistance2(that) {
        const dx = this.x - that.x;
        const dy = this.y - that.y;
        const dz = this.z - that.z;
        return dx * dx + dy * dy + dz * dz;
    }
    /** return a vector orthogonal to this one */
    ortho() {
        const k = this.largestAbsComponent();
        let temp;
        if (k == 1) {
            temp = new S2Point(1, 0, 0);
        }
        else if (k == 2) {
            temp = new S2Point(0, 1, 0);
        }
        else {
            temp = new S2Point(0, 0, 1);
        }
        return S2Point.normalize(S2Point.crossProd(this, temp));
    }
    /** Return the index of the largest component fabs */
    largestAbsComponent() {
        return S2Point.largestAbsComponent(this.x, this.y, this.z);
    }
    static largestAbsComponent(x, y, z) {
        const absX = Math.abs(x);
        const absY = Math.abs(y);
        const absZ = Math.abs(z);
        if (absX > absY) {
            if (absX > absZ) {
                return 0;
            }
            else {
                return 2;
            }
        }
        else {
            if (absY > absZ) {
                return 1;
            }
            else {
                return 2;
            }
        }
    }
    get(axis) {
        return (axis == 0) ? this.x : (axis == 1) ? this.y : this.z;
    }
    static fabs(p) {
        return new S2Point(Math.abs(p.x), Math.abs(p.y), Math.abs(p.z));
    }
    /** Returns a copy of 'p' rescaled to be unit-length. */
    static normalize(p) {
        let norm = p.norm();
        if (norm != 0) {
            norm = 1 / norm;
        }
        return S2Point.mul(p, norm);
    }
    axis(axis) {
        return (axis == 0) ? this.x : (axis == 1) ? this.y : this.z;
    }
    /** Return the angle between two vectors in radians */
    angle(va) {
        return Math.atan2(S2Point.crossProd(this, va).norm(), this.dotProd(va));
    }
    /**
     * Compare two vectors, return true if all their components are within a
     * difference of margin.
     */
    aequal(that, margin) {
        return this.x - Math.abs(that.x) < (margin) &&
            this.y - Math.abs(that.y) < (margin) &&
            this.z - Math.abs(that.z) < (margin);
    }
    equals(that) {
        if (!(that instanceof S2Point)) {
            return false;
        }
        return this.x == (that.x) && this.y == (that.y) && this.z == (that.z);
    }
    lessThan(vb) {
        if (this.x < (vb.x)) {
            return true;
        }
        if (vb.x < (this.x)) {
            return false;
        }
        if (this.y < (vb.y)) {
            return true;
        }
        if (vb.y < (this.y)) {
            return false;
        }
        if (this.z < (vb.z)) {
            return true;
        }
        return false;
    }
    compareTo(other) {
        return (this.lessThan(other) ? -1 : (this.equals(other) ? 0 : 1));
    }
    toFace() {
        let face = this.largestAbsComponent();
        if (this.axis(face) < (0)) {
            face += 3;
        }
        return face;
    }
    toR2Vector(face = this.toFace()) {
        let u;
        let v;
        switch (face) {
            case 0:
                u = this.y / (this.x);
                v = this.z / (this.x);
                break;
            case 1:
                u = (this.x * -1) / (this.y);
                v = this.z / (this.y);
                break;
            case 2:
                u = (this.x * -1) / (this.z);
                v = (this.y * -1) / (this.z);
                break;
            case 3:
                u = this.z / (this.x);
                v = this.y / (this.x);
                break;
            case 4:
                u = this.z / (this.y);
                v = (this.x * -1) / (this.y);
                break;
            case 5:
                u = (this.y * -1) / (this.z);
                v = (this.x * -1) / (this.z);
                break;
            default:
                throw new Error('Invalid face');
        }
        return new R2Vector_1.R2Vector(u, v);
    }
    toString() {
        return `Point(${this.x}, ${this.y}, ${this.z})`;
    }
}
exports.S2Point = S2Point;
/** Origin of the coordinate system, [0,0,0]. */
S2Point.ORIGIN = new S2Point(0, 0, 0);
/** Direction of the x-axis. */
S2Point.X_POS = new S2Point(1, 0, 0);
/** Opposite direction of the x-axis. */
S2Point.X_NEG = new S2Point(-1, 0, 0);
/** Direction of the y-axis. */
S2Point.Y_POS = new S2Point(0, 1, 0);
/** Opposite direction of the y-axis. */
S2Point.Y_NEG = new S2Point(0, -1, 0);
/** Direction of the z-axis. */
S2Point.Z_POS = new S2Point(0, 0, 1);
/** Opposite direction of the z-axis. */
S2Point.Z_NEG = new S2Point(0, 0, -1);
//# sourceMappingURL=S2Point.js.map