"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.S2Metric = void 0;
const Platform_1 = require("./Platform");
const S2_1 = require("./S2");
/**
 * Defines an area or a length cell metric.
 */
class S2Metric {
    /**
     * Defines a cell metric of the given dimension (1 == length, 2 == area).
     */
    constructor(_dim, _deriv) {
        this._dim = _dim;
        this._deriv = _deriv;
    }
    deriv() {
        return this._deriv;
    }
    dim() {
        return this._dim;
    }
    /** Return the value of a metric for cells at the given level. */
    getValue(level) {
        return this.deriv() * Math.pow(2, -this.dim() * level);
    }
    /**
     * Return the level at which the metric has approximately the given value.
     * For example, S2::kAvgEdge.GetClosestLevel(0.1) returns the level at which
     * the average cell edge length is approximately 0.1. The return value is
     * always a valid level.
     */
    getClosestLevel(/*double*/ value) {
        return this.getMinLevel((this.dim() == 1 ? S2_1.S2.M_SQRT2 : 2) * value);
    }
    /**
     * Return the minimum level such that the metric is at most the given value,
     * or S2CellId::kMaxLevel if there is no such level. For example,
     * S2::kMaxDiag.GetMinLevel(0.1) returns the minimum level such that all
     * cell diagonal lengths are 0.1 or smaller. The return value is always a
     * valid level.
     */
    getMinLevel(value /*double*/) {
        if (value <= 0) {
            return S2_1.S2.MAX_LEVEL;
        }
        // This code is equivalent to computing a floating-point "level"
        // value and rounding up.
        // let exponent = Platform.getExponent(value / ((1 << this.dim()) * this.deriv()));
        const exponent = Platform_1.Platform.getExponent(this.deriv() / value);
        // let level = Math.max(0,
        //     Math.min(S2.MAX_LEVEL, -((exponent - 1) >> (this.dim() - 1))));
        const level = Math.max(0, Math.min(S2_1.S2.MAX_LEVEL, -(exponent >> (this.dim() - 1))));
        // assert (level == S2CellId.MAX_LEVEL || getValue(level) <= value);
        // assert (level == 0 || getValue(level - 1) > value);
        return level;
    }
    /**
     * Return the maximum level such that the metric is at least the given
     * value, or zero if there is no such level. For example,
     * S2.kMinWidth.GetMaxLevel(0.1) returns the maximum level such that all
     * cells have a minimum width of 0.1 or larger. The return value is always a
     * valid level.
     */
    getMaxLevel(value /*double*/) {
        if (value <= 0) {
            return S2_1.S2.MAX_LEVEL;
        }
        // This code is equivalent to computing a floating-point "level"
        // value and rounding down.
        const exponent = Platform_1.Platform.getExponent(this.deriv() / value);
        const level = Math.max(0, Math.min(S2_1.S2.MAX_LEVEL, exponent >> (this.dim() - 1)));
        // assert (level == 0 || getValue(level) >= value);
        // assert (level == S2CellId.MAX_LEVEL || getValue(level + 1) < value);
        return level;
    }
}
exports.S2Metric = S2Metric;
//# sourceMappingURL=S2Metric.js.map